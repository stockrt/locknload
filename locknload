#!/usr/bin/env bash

# Copyright (C) 2012 Rogério Carvalho Schneider <stockrt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# locknload
#
# Created:  Jan 21, 2012
# Author:   Rogério Carvalho Schneider <stockrt@gmail.com>

# Requires:
#   - nfslock / lockd (nfs-utils)
#   - flock (util-linux)
#   - lockfile (procmail)
#   - rw access to the lockdir

#############
## CONFIGS ##
#############

# Exit on command errors
#set -e
# Exit on variable expansion errors
set -u


#############
## DEFINES ##
#############

# Version number
version="0.0.1"
# Program name
program="$(basename "$0")"

verbosity=0
logfile="None"
lockdir="None"
lockmode="flock"
command="None"
tempdir="${TMP:-/tmp}"


###############
## FUNCTIONS ##
###############

usage () {
    echo "
Usage: locknload [-v] [-o logfile] -d lockdir -c \"command\"
    -h
        Display this help text and exit.
    -V
        Display version number and exit.
    -v
        Verbosity level. Can be used more than once to increase verbosity.
        Default: $verbosity
    -o logfile
        If defined all the execution output will be redirected to the logfile.
        Default: $logfile
    -d lockdir
        Directory holding the locks. Should be an NFS directory shared among
        the servers running concurrent commands.
        Lockfiles found inside the lockdir are defined using some kind of
        textual hash derived from the original command. Inside the lockfile
        you will find the original command, the host which got the lock and
        the start/finish/fail execution time.
        Default: $lockdir
    -m mode
        Lock acquisition mode. Available modes are:
            flock       : Uses flock command from util-linux package.
        Modes not yet implemented:
            lockfile    : Uses lockfile command from procmail package.
            hardlink    : Uses the technique described on open(2).
            mkdir       : Uses a directory as a lock.
        Default: $lockmode
    -c command
        The command to be run itself. If you are trying to run something more
        complex, perhaps multiple commands with \"&&\" or \";\" or commands
        with parameters, you should use quoting to encapsulate the command.
        Default: $command"
}

log () {
    verbositylevel=$1
    shift
    logmessage="$@"

    if [[ $verbosity -ge $verbositylevel ]]
    then
        if [[ "$logfile" == "None" ]]
        then
            echo "$logmessage"
        else
            # Syslog format
            #echo "$(date +"%b %d %H:%M:%S") $HOSTNAME $program[$$]: ($command): $logmessage"
            # Slack and yet more useful format
            echo "$(date) $HOSTNAME $program[$$]: ($command): $logmessage"
        fi
    fi
}

splash () {
    if [[ "$logfile" == "None" && $verbosity -ge 2 ]]
    then
        echo
    fi
    log 2 "Program      : $program"
    log 2 "Command      : $command"
    log 2 "Verbosity    : $verbosity"
    log 2 "Logfile      : $logfile"
    log 2 "Lockdir      : $lockdir"
    log 2 "Lockfile     : $lockfile"
    log 2 "Lockmode     : $lockmode"
    log 2 "Tempdir      : $tempdir"
    log 2 "Tempfile     : $tempfile"
    if [[ "$logfile" == "None" && $verbosity -ge 2 ]]
    then
        echo
    fi
}


##########
## ARGS ##
##########

while getopts hVvo:d:m:c: arg
do
    case $arg in
        h)
            usage
            exit 0
            ;;
        V)
            echo "$program version: $version"
            exit 0
            ;;
        v)
            let "verbosity+=1"
            ;;
        o)
            logfile="$OPTARG"
            ;;
        d)
            lockdir="$OPTARG"
            ;;
        m)
            lockmode="$OPTARG"
            ;;
        c)
            command="$OPTARG"
            ;;
        *)
            usage
            exit 1
            ;;
    esac
done
shift $(($OPTIND - 1))

# Obrigatory arguments check
if [[ "$lockdir" == "None" || "$command" == "None" ]]
then
    echo "Arguments lockdir and command must be specified."
    usage
    exit 1
fi

# Invalid options check
if [[ "$lockmode" != "flock" ]]
then
    echo "Invalid lockmode: $lockmode"
    usage
    exit 1
fi


##########
## MAIN ##
##########

# Logfile
if [[ "$logfile" != "None" ]]
then
    log 4 "Calculating logdir for logfile: $logfile"
    curdir="$PWD"
    cd "$(dirname "$logfile")"
    logfile="$PWD/$(basename "$logfile")"
    log 4 "Calculated logdir for logfile: $logfile"
    cd "$curdir"
    log 4 "Redirecting output (stdout and stderr) to logfile: $logfile"
    exec >> "$logfile" 2>&1
fi

if [[ "$logfile" != "None" ]]
then
    log 0 "############################################################"
    log 0 "Started execution"
else
    log 1 "############################################################"
    log 1 "Started execution"
fi

# Lockdir
log 2 "Creating lockdir: $lockdir"
if [[ ! -d "$lockdir" ]]
then
    mkdir -p "$lockdir"
    log 3 "Created lockdir: $lockdir"
else
    log 3 "Lockdir already exists: $lockdir"
fi

# Tempfile creation
log 2 "Creating tempfile"
tempfile="$(mktemp $tempdir/tmp.XXXXXXXXXXXXXXXXXXXX)"
log 3 "Created tempfile: $tempfile"

# Tempfile permissions
log 2 "Changing permissions of tempfile: $tempfile"
chmod 755 "$tempfile"
log 3 "Changed permissions of tempfile: $tempfile"

# Lock
lockname="$(sed 's/[^[:alnum:]]/_/g' <<< "$command" | tr -s _)"
lockname="${lockname#_}"
lockname="${lockname%_}"
lockfile="$lockdir/$lockname.lock"

# Lock data
lockdata="$command
\$HOSTNAME
start:  \$(date)"

######################
## Temporary script ##
######################
log 2 "Creating command script using tempfile: $tempfile"
echo "#!/usr/bin/env bash

# Exit on command errors
#set -e
# Exit on variable expansion errors
set -u

# Information into lockfile
echo \"$lockdata\" > \"$lockfile\"

# Running the command itself
$command
ret=\$?

# More information into lockfile
if [[ \$ret -eq 0 ]]
then
    echo \"finish: \$(date)\" >> \"$lockfile\"
else
    echo \"fail:   \$(date)\" >> \"$lockfile\"
fi

# And yet more information into lockfile
echo \"return code: \$ret\" >> \"$lockfile\"

# Signaling that we succeded acquiring the lock
> \${0}.ok

# Propagating the return code from the command
exit \$ret" > "$tempfile"
log 3 "Created command script using tempfile: $tempfile"
######################
## Temporary script ##
######################

# Splash screen
splash

###################
## Lock and Load ##
###################
if [[ "$logfile" != "None" ]]
then
    log 2 "Starting execution of locked command"
    log 2 "Acquiring lock on lockfile: $lockfile"
else
    log 2 "Starting execution of locked command: $command"
    log 2 "Acquiring lock on lockfile: $lockfile"
fi

# Lock
flock -n "$lockfile" "$tempfile"
ret=$?

if [[ -f "${tempfile}.ok" ]]
then
    if [[ "$logfile" != "None" ]]
    then
        log 0 "Acquired lock on lockfile: $lockfile"
    else
        log 1 "Acquired lock on lockfile: $lockfile"
    fi
else
    if [[ "$logfile" != "None" ]]
    then
        log 0 "Could not acquire lock on lockfile: $lockfile"
        log 3 "Finished execution of locked command"
    else
        log 1 "Could not acquire lock on lockfile: $lockfile"
        log 3 "Finished execution of locked command: $command"
    fi
fi
###################
## Lock and Load ##
###################

# Tempfile cleanup
log 2 "Cleaning tempfile: $tempfile"
rm -f "$tempfile" "${tempfile}.ok"
log 3 "Cleaned tempfile: $tempfile"

if [[ "$logfile" != "None" ]]
then
    log 0 "Finished execution. Return code: $ret"
    log 0 "############################################################"
else
    log 1 "Finished execution. Return code: $ret"
    log 1 "############################################################"
fi

# Return code from command
exit $ret
